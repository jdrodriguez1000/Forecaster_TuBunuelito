{
    "phase": "integration_tests",
    "timestamp": "2026-02-26T14:19:35.845455",
    "description": "Reporte de ejecución de pruebas de integración",
    "components": [
        "extraction_flow"
    ],
    "metrics": {
        "passed": 2,
        "failed": 2,
        "skipped": 0,
        "total": 4
    },
    "details": [
        {
            "test_name": "test_full_extraction_flow_real",
            "component": "extraction_flow",
            "status": "passed",
            "duration": 3.0239,
            "error_message": null
        },
        {
            "test_name": "test_audit_report_content",
            "component": "extraction_flow",
            "status": "failed",
            "duration": 0.0205,
            "error_message": "self = <test_extraction_flow.TestExtractionIntegration object at 0x00000268263E8740>\n\n    def test_audit_report_content(self):\n        \"\"\"\n        [POSITIVO] Valida que el archivo JSON de auditoría tenga el formato correcto\n        y contenga las previsualizaciones solicitadas.\n        \"\"\"\n        report_path = os.path.join(self.reports_path, \"phase_01_extractions_latest.json\")\n        assert os.path.exists(report_path)\n    \n        import json\n        with open(report_path, \"r\", encoding=\"utf-8\") as f:\n            data = json.load(f)\n    \n        # Verificar estructura de auditoría por tabla\n        for table, audit in data[\"table_audits\"].items():\n>           if audit[\"status\"] != \"error\":\n               ^^^^^^^^^^^^^^^\nE           KeyError: 'status'\n\ntests\\integration\\test_extraction_flow.py:64: KeyError"
        },
        {
            "test_name": "test_incremental_logic_simulation",
            "component": "extraction_flow",
            "status": "failed",
            "duration": 0.0552,
            "error_message": "self = <test_extraction_flow.TestExtractionIntegration object at 0x00000268263E89E0>\ntmp_path = WindowsPath('C:/Users/USUARIO/AppData/Local/Temp/pytest-of-USUARIO/pytest-342/test_incremental_logic_simulat0')\n\n    def test_incremental_logic_simulation(self, tmp_path):\n        \"\"\"\n        [NEGATIVO/LÓGICA] Verifica que la lógica incremental detecte correctamente\n        el last_date incluso si forzamos un escenario controlado.\n        \"\"\"\n        # Usamos una carpeta temporal para no afectar los datos reales de data/01_raw\n        temp_raw = tmp_path / \"raw\"\n        temp_raw.mkdir()\n    \n        # Crear un archivo parquet 'dummy' con fechas viejas\n        table_name = \"ventas\"\n        dummy_file = temp_raw / f\"{table_name}.parquet\"\n        old_data = pd.DataFrame({\n            \"fecha\": pd.to_datetime([\"2020-01-01\", \"2020-01-02\"]),\n            \"unidades_totales\": [100, 110]\n        })\n        old_data.to_parquet(dummy_file)\n    \n        # Instanciar loader y parchear la ruta de data_raw\n        with patch.object(self.loader, \"raw_path\", str(temp_raw)):\n            # Simular fetch_table para que devuelva solo 1 fila nueva\n            new_row = pd.DataFrame({\n                \"fecha\": pd.to_datetime([\"2020-01-03\"]),\n                \"unidades_totales\": [120]\n            })\n    \n            with patch.object(self.loader, \"_fetch_table\", return_value=new_row) as mock_fetch:\n                self.loader.run_extraction()\n    \n                # Verificar que fetch_table fue llamado con la fecha máxima (2020-01-02)\n                called_date = mock_fetch.call_args[1][\"last_date\"]\n>               assert called_date == pd.Timestamp(\"2020-01-02\")\nE               AssertionError: assert None == Timestamp('2020-01-02 00:00:00')\nE                +  where Timestamp('2020-01-02 00:00:00') = <class 'pandas._libs.tslibs.timestamps.Timestamp'>('2020-01-02')\nE                +    where <class 'pandas._libs.tslibs.timestamps.Timestamp'> = pd.Timestamp\n\ntests\\integration\\test_extraction_flow.py:102: AssertionError"
        },
        {
            "test_name": "test_connection_failure_handling",
            "component": "extraction_flow",
            "status": "passed",
            "duration": 0.026,
            "error_message": null
        }
    ]
}